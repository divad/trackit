#!/usr/bin/python
#
# This file is part of trackit.
#
# trackit is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# trackit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with trackit.  If not, see <http://www.gnu.org/licenses/>.

import Pyro4
import syslog
import signal
import sys
import os.path
import os
import subprocess
import re
import ConfigParser
import MySQLdb as mysql
import traceback # remove
import ldap
import imp
import shutil
import time
from multiprocessing import Process, Value
import traceback
import smtplib

TRACKIT_CONFIG_FILE = '/data/forgemgr/trackit.conf'
VERSION             = "0.18"
DEBUG               = True

Pyro4.config.SERVERTYPE = "multiplex"
Pyro4.config.SOCK_REUSE = True

class InternalError(Exception):
	def __init__(self, message, error_data={}):
		super(InternalError, self).__init__(message)
		self.data = error_data

class TracKitDaemon(object):

	def __init__(self):
		## Open syslog 
		syslog.openlog("trackitd",syslog.LOG_PID)
		syslog.syslog('Starting trackitd/' + str(VERSION))

		## Create some blank variables for later use
		self.db = None
		self.graceful = None
		self.graceful_waiting = Value('i',1	)

################################################################################

	def get_cursor(self):
		if self.db:
			if self.db.open:
				## sadly, self.db.open returns true even if it actually isn't open due to MySQL being a pile of garbage
				## so we will try a 'test' query. this is what virtually all connection pools use. We don't need/want a connection pool as this is a single thread daemon.
				try:
					curd = self.db.cursor(mysql.cursors.DictCursor)
					curd.execute('SELECT 1')
					result = curd.fetchone();

					if result:
						return curd
				except (AttributeError, mysql.OperationalError):
					syslog.syslog("MySQL connection has been closed, attempting reconnect")

		## If we didn't return a cursor then we need to connect and return a cursor
		return self.db_connect()
		
	def db_connect(self):
		syslog.syslog("Attempting connection to MySQL")
		self.db = mysql.connect(self.config['DB_SERV'],self.config['DB_USER'],self.config['DB_PASS'],self.config['DB_NAME'])
		curd = self.db.cursor(mysql.cursors.DictCursor)
		## mysql is a pile of fucking dogshite. We must set the isolation level to the standard (rather than what MySQL uses by default which is REPEATABLE READ)
		## otherwise changes from the web app wont be reflected to us because MySQL snapshots the database for a 'consistent read' so even after changes occur you see the original state
		curd.execute("SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED")
		syslog.syslog("Connection to MySQL established")
		return curd
		
	def load_config(self, filename):
		d = imp.new_module('config')
		d.__file__ = filename
		try:
			with open(filename) as config_file:
				exec(compile(config_file.read(), filename, 'exec'), d.__dict__)
		except IOError as e:
			syslog.syslog('Unable to load configuration file (%s)' % e.strerror)
			sys.exit(1)
		self.config = {}
		for key in dir(d):
			if key.isupper():
				self.config[key] = getattr(d, key)
				
		return True

################################################################################
		
	def db_close(self):
		if self.db.open:
			self.db.close()
		
################################################################################
		
	def sysexec(self,command):
		try:
			commands = command.split(' ')
			proc = subprocess.Popen(commands,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
			(stdoutdata, stderrdata) = proc.communicate()
			return (proc.returncode,str(stdoutdata),str(stderrdata))
		except Exception as ex:
			syslog.syslog("sysexec exception: " + str(ex))
			return (1,"",str(ex))
		
################################################################################
		
	def svn_create(self,name):
		## Check the svn folder does not exist
		svn_path = os.path.join(self.config['SVN_ROOT'],name)
		if os.path.lexists(svn_path):
			syslog.syslog('Could not create svn repo ' + svn_path + ': the directory already exists')
			raise InternalError("The subversion repository path " + svn_path + " already exists")

		## Run svnadmin create
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/svnadmin create ' + svn_path)
		if rcode > 0:
			syslog.syslog('Could not create svn repo ' + svn_path + ': svnadmin returned an error code')
			syslog.syslog('svnadmin stdout:' + stdoutdata)
			syslog.syslog('svnadmin stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("The subversion repository could not be created due to an internal error. Please contact your system administrator.",error_data)
		
		syslog.syslog('Created svn repository ' + name)
		self.regenerate_authz_file()
		self.regenerate_samba_hooks_file()
		return svn_path

################################################################################
		
	def git_create(self,name):
		git_path = os.path.join(self.config['GIT_ROOT'],name)
		if os.path.lexists(git_path):
			syslog.syslog('Could not create git repo ' + git_path + ': the directory already exists')
			raise InternalError("The git repository path " + git_path + " already exists")

		## Run git init
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/git init --bare ' + git_path)
		if rcode > 0:
			syslog.syslog('Could not create git repo ' + git_path + ': git init returned an error code')
			syslog.syslog('git init stdout:' + stdoutdata)
			syslog.syslog('git init stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("git init returned an error. Please contact your system administrator.",error_data)
		
		syslog.syslog('Created git repository ' + name)
		self.git_auth_config(name)
		return git_path

################################################################################
		
	def hg_create(self,name):
		hg_path = os.path.join(self.config['HG_ROOT'],name)
		if os.path.lexists(hg_path):
			syslog.syslog('Could not create hg repo ' + hg_path + ': the directory already exists')
			raise InternalError("The hg repository path " + hg_path + " already exists")

		## Run hg init
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/hg init ' + hg_path)
		if rcode > 0:
			syslog.syslog('Could not create hg repo ' + hg_path + ': hg init returned an error code')
			syslog.syslog('hg init stdout:' + stdoutdata)
			syslog.syslog('hg init stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("hg init returned an error. Please contact your system administrator.",error_data)
		
		syslog.syslog('Created hg repository ' + name)
		self.hg_auth_config(name)
		return hg_path
		
################################################################################
			
	def trac_create(self,name,src_type,src_path=""):
		if DEBUG: syslog.syslog('internal method trac_create called with 1:' + name + ' 2:' + src_type + ' 3:' + src_path)
		## Check trac folder does not exist
		trac_path = os.path.join(self.config['TRAC_ROOT'],name)
		if os.path.lexists(trac_path):
			raise InternalError("The trac path " + trac_path + " already exists")

		trac_str = ""
		if src_type == "svn":
			trac_str = " svn " + src_path
		elif src_type == "git":
			trac_str = " git " + src_path
		elif src_type == "hg":
			trac_str = " hg " + src_path
	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/trac-admin ' + trac_path + ' initenv ' + name + ' sqlite:db/trac.db' + trac_str)

		if rcode > 0:
			syslog.syslog('Could not trac instance ' + trac_path + ': trac-admin returned an error code')
			syslog.syslog('trac-admin stdout:' + stdoutdata)
			syslog.syslog('trac-admin stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("The Trac instance could not be created due to an internal error. Please contact your system administrator.",error_data)
		else:
			syslog.syslog('Created trac instance ' + name + " with source type: " + src_type)

		## Open the config file		
		config_path = os.path.join(trac_path,'conf','trac.ini')
		
		tconfig = ConfigParser.RawConfigParser()
		tconfig.read(config_path)

		## LOGO
		tconfig.set('header_logo','src','https://www.southampton.ac.uk/images/bg_logo_small.png')
		tconfig.set('header_logo','alt','Trac')
		tconfig.set('header_logo','link','https://trac.soton.ac.uk/' + name + '/')
		

		if src_type == "svn":	
			tconfig.add_section('components')
			tconfig.set('components','tracopt.versioncontrol.svn.*','enabled')
		elif src_type == "git":
			tconfig.add_section('components')
			tconfig.set('components','tracopt.versioncontrol.git.*','enabled')

		## email notifications
		tconfig.set('notification','always_notify_owner','true')
		tconfig.set('notification','always_notify_reporter','true')
		tconfig.set('notification','always_notify_updater','true')
		tconfig.set('notification','smtp_default_domain','soton.ac.uk')
		tconfig.set('notification','smtp_enabled','true')
		tconfig.set('notification','smtp_from','noreply@soton.ac.uk')
		tconfig.set('notification','smtp_replyto','noreply@soton.ac.uk')
		
		## other settings
		tconfig.set('project','admin','noreply@soton.ac.uk')
		
		with open(config_path,'wb') as cfp:
			tconfig.write(cfp)
			cfp.flush()
			os.fsync(cfp.fileno())
			
		## Create the auth file
		self.trac_auth_config(name)
		
		## Restart httpd :(
		self.server_graceful()
		
		return trac_path

################################################################################	

## httpd restart stuff
		
	def server_graceful(self):
		if self.graceful:
			if self.graceful.is_alive():
				## httpd restart request process exists
				## work out if its waiting or currently restarting
				if self.graceful_waiting.value == 1:
					## Its waiting, so we need not do anything
					return
				else:
					## restart has started, so we need to wait until it is done, then schedule another
					self.graceful.join()

		## if we got this far httpd restart has not been queued
		self.graceful_waiting = Value('i',1)
		syslog.syslog('httpd restart scheduled for 30 seconds time')
		self.graceful = Process(target=self.do_server_graceful, args=(self.graceful_waiting,))
		self.graceful.start()

	def do_server_graceful(self,waiting):
		## sleep
		time.sleep(30)
		waiting.value = 0

		syslog.syslog('asking apachectl for a httpd config test')
	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/sudo -n /usr/sbin/apachectl configtest')

		if rcode > 0:
			syslog.syslog('CRITICAL: httpd configtest failed - apachectl returned an error code:' + str(rcode))
			syslog.syslog('apachectl stdout:' + stdoutdata)
			syslog.syslog('apachectl stderr:' + stderrdata)			
			syslog.syslog('CRITICAL: not restarting httpd because a restart would break')
			
			self.mail_alert("ALERT: Forge service CRITICAL","""This is an automated message from the trackitd program on Forge. 

An attempt to restart the web server failed because a pre-restart configtest failed. The next automatic restart of Apache httpd will leave the system broken. Please fix this error manually.

The return code from apache ctl was: %s

The stdout data was: %s

The stderr data was: %s """ % (rcode, stdoutdata, stderrdata))

		else:
			syslog.syslog('httpd configtest OK')
		
		syslog.syslog('asking apachectl for a graceful restart')
	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/sudo -n /usr/sbin/apachectl graceful')

		if rcode > 0:
			syslog.syslog('CRITICAL: httpd graceful restart failed - apachectl returned an error code:' + str(rcode))
			syslog.syslog('apachectl stdout:' + stdoutdata)
			syslog.syslog('apachectl stderr:' + stderrdata)			
			
			self.mail_alert("ALERT: Forge service UNAVAILABLE","""This is an automated message from the trackitd program on Forge. 

An attempt to restart the web server failed and as such the system is now not avaialble to its users. Please restore service manually.

The return code from apache ctl was: %s

The stdout data was: %s

The stderr data was: %s """ % (rcode, stdoutdata, stderrdata))
		else:
			syslog.syslog('httpd graceful restart OK')

	def mail_alert(self,subject, message):
		if self.config['EMAIL_ALERTS']:
			message = """Subject: %s

%s""" % (subject, message)

			try:
			   smtpObj = smtplib.SMTP(self.config['SMTP_SERVER'])
			   smtpObj.sendmail(self.config['EMAIL_FROM'], self.config['ADMINS'], message)         
			   syslog.syslog('critical error alert e-mail has been sent')
			except SMTPException as ex:
			   syslog.syslog('critical error alert e-mail could not be sent: ' + str(ex))

		
################################################################################	
		
	def trac_auth_config(self,name):			
		curd = self.get_cursor()
		curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
		repo = curd.fetchone()
		
		if repo == None:
			raise InternalError("Could not find repo '" + name + "' in the database")
		
		if repo['web_type'] != 'trac':
			raise InternalError("Could not build trac auth config for repo '" + name + "' because web_type is not set to trac")
			
		if str(repo['state']) == "2":
			## suspend 
			location = "/" + name 
			f = open(os.path.join(self.config['TRAC_CONF_DIR'], name + ".conf"), 'w')
			f.write("""<Location %s>\nRedirectMatch .* https://forge.soton.ac.uk/suspended\n</Location>""" % (location))
			f.flush()
			os.fsync(f.fileno())
			f.close()
			syslog.syslog('Suspended trac auth config for: ' + name)
			return 
		elif str(repo['state']) == "3":
			## delete
			os.remove(os.path.join(self.config['TRAC_CONF_DIR'], name + ".conf"))
			syslog.syslog('Removed trac auth config for: ' + name)
			return 
	
		## create set
		required_users = set()
		ldap_groups    = ""
		teamauthz_required = False
		teamauthz_string = ""
		
		## get rules now
		curd.execute('SELECT * FROM `rules` WHERE `rid` = %s', (repo['id']))
		rules = curd.fetchall()	

		for rule in rules:
			if rule['web'] == 1:
				if rule['source'] == 'internal':
					required_users.add(rule['name'])
					
				elif rule['source'] == 'team':
					curd.execute('SELECT * FROM `teams` WHERE `name` = %s',(rule['name']))
					team = curd.fetchone()
					
					if not team == None:
						teamauthz_required = True
						teamauthz_string += "\nRequire group " + team['name']
							
				elif rule['source'] == 'adgroup':
					groupdn = self.ldap_get_group_dn(rule['name'])
					
					if not groupdn == None:
						ldap_groups += "\nRequire ldap-group " + groupdn
				
		location = "/" + name 
		
		if repo['web_security'] == 1:
			location = location + "/login"
					
		users_string = ""
		for user in required_users:
			users_string = users_string + user + " "
			
		if len(users_string) > 0:
			users_string = "\nRequire ldap-user " + users_string
			
		if teamauthz_required:
			teamauthz_string = "\nAuthzLDAPAuthoritative off\nWSGIAuthGroupScript /data/trackit/trackit/auth/teams.wsgi" + teamauthz_string
	
		f = open(os.path.join(self.config['TRAC_CONF_DIR'], name + ".conf"), 'w')
		f.write("""<Location %s>
AuthType Basic
AuthName "%s Trac Project"
AuthBasicProvider ldap
AuthLDAPUrl ldaps://nlbldap.soton.ac.uk/dc=soton,dc=ac,dc=uk?cn?? %s %s %s
</Location>
""" % (
			location,
			name,
			teamauthz_string,
			users_string,
			ldap_groups,
		))
		
		f.flush()
		os.fsync(f.fileno())
		f.close()
		
		syslog.syslog('trac auth config rebuilt for instance ' + name)

################################################################################	
		
	def git_auth_config(self,name):			
		curd = self.get_cursor()
		curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
		repo = curd.fetchone()

		if repo == None:
			raise InternalError("Could not find repo '" + name + "' in the database")
		
		if repo['src_type'] != 'git':
			raise InternalError("Could not build git auth config for repo '" + name + "' because src_type is not set to git")
			
		if str(repo['state']) == "2":
			## suspend 
			location = "/" + name 
			f = open(os.path.join(self.config['GIT_CONF_DIR'], name + ".conf"), 'w')
			f.write("""<Location %s>\nRedirectMatch .* https://forge.soton.ac.uk/suspended\n</Location>""" % (location))
			f.flush()
			os.fsync(f.fileno())
			f.close()
			syslog.syslog('Suspended git auth config for: ' + name)
			return 
		elif str(repo['state']) == "3":
			## delete
			os.remove(os.path.join(self.config['GIT_CONF_DIR'], name + ".conf"))
			syslog.syslog('Removed git auth config for: ' + name)
			return 
	
		## create set
		ro_users = ""
		rw_users = ""
		ro_teams = ""
		rw_teams = ""	
		
		## get rules now
		curd.execute('SELECT * FROM `rules` WHERE `rid` = %s', (repo['id']))
		rules = curd.fetchall()	

		for rule in rules:
			if rule['source'] == 'internal':
				if rule['src'] >= 1:
					ro_users += rule['name'] + " "

					if rule['src'] == 2:
						rw_users += rule['name'] + " "
				
			elif rule['source'] == 'team':
				if rule['src'] >= 1:
					ro_teams += "\nRequire group " + rule['name']

					if rule['src'] == 2:
						rw_teams += "\nRequire group " + rule['name']

		location = "/" + name 
		
		if len(ro_users) > 0:
			ro_users = "\nRequire user " + ro_users

		if len(rw_users) > 0:
			rw_users = "\nRequire user " + rw_users

		f = open(os.path.join(self.config['GIT_CONF_DIR'], name + ".conf"), 'w')
		f.write("""<Location %s>
AuthType Basic
AuthName "%s Git Repository"
AuthBasicProvider wsgi
WSGIAuthUserScript /data/trackit/trackit/auth/users.wsgi
WSGIAuthGroupScript /data/trackit/trackit/auth/teams.wsgi
%s %s
</Location>
<Location %s/git-receive-pack>
AuthType Basic
AuthName "%s Git Repository"
AuthBasicProvider wsgi
WSGIAuthUserScript /data/trackit/trackit/auth/users.wsgi
WSGIAuthGroupScript /data/trackit/trackit/auth/teams.wsgi
%s %s
</Location>
""" % (
			location,
			name,
			ro_users,
			ro_teams,
			location,
			name,
			rw_users,
			rw_teams,
		))
		
		f.flush()
		os.fsync(f.fileno())
		f.close()
		
		self.server_graceful()
		syslog.syslog('git auth config rebuilt for instance ' + name)


################################################################################

	def hg_auth_config(self,name):			
		curd = self.get_cursor()
		curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
		repo = curd.fetchone()

		if repo == None:
			raise InternalError("Could not find repo '" + name + "' in the database")
		
		if repo['src_type'] != 'hg':
			raise InternalError("Could not build hg auth config for repo '" + name + "' because src_type is not set to hg")
			
		if str(repo['state']) == "2":
			## suspend 
			location = "/" + name 
			f = open(os.path.join(self.config['HG_CONF_DIR'], name + ".conf"), 'w')
			f.write("""<Location %s>\nRedirectMatch .* https://forge.soton.ac.uk/suspended\n</Location>""" % (location))
			f.flush()
			os.fsync(f.fileno())
			f.close()
			syslog.syslog('Suspended hg auth config for: ' + name)
			return 
		elif str(repo['state']) == "3":
			## delete
			os.remove(os.path.join(self.config['HG_CONF_DIR'], name + ".conf"))
			syslog.syslog('Removed hg auth config for: ' + name)
			return 
	
		## create set
		ro_users = ""
		rw_users = ""
		ro_teams = ""
		rw_teams = ""	
		
		## get rules now
		curd.execute('SELECT * FROM `rules` WHERE `rid` = %s', (repo['id']))
		rules = curd.fetchall()	

		for rule in rules:
			if rule['source'] == 'internal':
				if rule['src'] >= 1:
					ro_users += rule['name'] + " "

					if rule['src'] == 2:
						rw_users += rule['name'] + " "
				
			elif rule['source'] == 'team':
				if rule['src'] >= 1:
					ro_teams += "\nRequire group " + rule['name']

					if rule['src'] == 2:
						rw_teams += "\nRequire group " + rule['name']

		location = "/" + name 
		
		if len(ro_users) > 0:
			ro_users = "\nRequire user " + ro_users

		if len(rw_users) > 0:
			rw_users = "\nRequire user " + rw_users

		f = open(os.path.join(self.config['HG_CONF_DIR'], name + ".conf"), 'w')
		f.write("""<Location %s>
<Limit GET PROPFIND OPTIONS REPORT>
AuthType Basic
AuthName "%s Mercurial Repository"
AuthBasicProvider wsgi
WSGIAuthUserScript /data/trackit/trackit/auth/users.wsgi
WSGIAuthGroupScript /data/trackit/trackit/auth/teams.wsgi
%s %s
</Limit>
<LimitExcept GET PROPFIND OPTIONS REPORT>
AuthType Basic
AuthName "%s Mercurial Repository"
AuthBasicProvider wsgi
WSGIAuthUserScript /data/trackit/trackit/auth/users.wsgi
WSGIAuthGroupScript /data/trackit/trackit/auth/teams.wsgi
%s %s
</Location>
""" % (
			location,
			name,
			ro_users,
			ro_teams,
			name,
			rw_users,
			rw_teams,
		))
		
		f.flush()
		os.fsync(f.fileno())
		f.close()
		
		self.server_graceful()
		syslog.syslog('hg auth config rebuilt for instance ' + name)


################################################################################

	def svn_notify_config(self,name,address):			
		curd = self.get_cursor()
		curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
		repo = curd.fetchone()
	
		if repo == None:
			raise InternalError("Could not find repo '" + name + "' in the database")
		
		if repo['src_type'] != 'svn':
			raise InternalError("Could not configure svn notification'" + name + "' because src_type is not set to svn")

		hook_file = os.path.join(self.config['SVN_ROOT'],name,'hooks','post-commit')
			
		address = address.strip()
		if len(address) > 0:

			f = open(hook_file, 'w')
			f.write("""#!/bin/sh
## Do not edit this file. It was automatically generated by trackit-daemon
REPOS="$1"
REV="$2"
/usr/local/bin/svnnotify --repos-path "$REPOS" \
--revision "$REV" --to %s \
--from noreply@soton.ac.uk --with-diff \
--subject-prefix "SVN commit on repository '%s': " \
--header "This is a notification of a commit made to the Subversion repository '%s'"
""" % (
				address,
				name,
				name,
			))
			
			f.flush()
			os.fsync(f.fileno())
			f.close()
			
			## chmod the file to executable
			os.chmod(hook_file,0700)
			
			syslog.syslog('Wrote out post-commit hook for repo: ' + name)
		else:
			## remove the file instead
			if os.path.exists(hook_file):
				os.unlink(hook_file)
			
			syslog.syslog('Removed post-commit hook for repo: ' + name)
		
################################################################################

	def ldap_get_group_dn(self,group_name):

		ldapserver = ldap.initialize(self.config['LDAP_URI'])
		results = ldapserver.search_s(self.config['LDAP_SEARCH_BASE'], ldap.SCOPE_SUBTREE,"(cn=" + group_name +")")

		for result in results:
			dn    = result[0]
			attrs = result[1]

			if not dn == None:
				if "member" in attrs:
					return dn

		return None

################################################################################	
		
	def trac_add_admin(self,trac_path,username):	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/trac-admin ' + trac_path + ' permission add ' + username + ' TRAC_ADMIN')		

		if rcode > 0:
			syslog.syslog('Error returned from trac-admin permission add on instance ' + trac_path + '. Error code:' + str(rcode))
			syslog.syslog('trac-admin stdout:' + stdoutdata)
			syslog.syslog('trac-admin stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("Could not set trac permissions",error_data)
		else:
			syslog.syslog("Granted TRAC_ADMIN to " + username + " on instance " + trac_path)

################################################################################
			
	def trac_remove_admin(self,trac_path,username):	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/trac-admin ' + trac_path + ' permission remove ' + username + ' TRAC_ADMIN')		
			
		if rcode > 0:
			syslog.syslog('Error returned from trac-admin permission remove on instance ' + trac_path + '. Error code:' + str(rcode))
			syslog.syslog('trac-admin stdout:' + stdoutdata)
			syslog.syslog('trac-admin stderr:' + stderrdata)
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("Could not set trac permissions",error_data) 
		else:
			syslog.syslog("Revoked TRAC_ADMIN from " + username + " on instance " + trac_path)

################################################################################
			
	def regenerate_authz_file(self):
		## regenerate the entire authz file
		zconfig = ConfigParser.RawConfigParser()
		
		## Generate teams
		zconfig.add_section('groups')
		curd = self.get_cursor()
		curd.execute('SELECT * FROM `teams` ORDER BY `name`')
		teams = curd.fetchall()
		
		for team in teams:
			curd.execute('SELECT * FROM `team_members` WHERE `tid` = %s', (team['id']))
			members = curd.fetchall()
			
			memberstr = ""
			for member in members:
				memberstr += " " + member['username'] + ","
				
			if memberstr.endswith(','):
				## remove the trailing comma and starting space
				memberstr = memberstr[1:-1]
				zconfig.set('groups',team['name'],memberstr)
				
		## Generate each repo rules
		curd.execute('SELECT * FROM `repos` WHERE `state` = 1 OR `state` = 0')
		repos = curd.fetchall()
		
		for repo in repos:
			section_name = repo['name'] + ":/"
			zconfig.add_section(section_name)
			curd.execute('SELECT * FROM `rules` WHERE `rid` = %s', (repo['id']))
			rules = curd.fetchall()	

			for rule in rules:
				if rule['source'] == 'internal':
					prefix = ""
				elif rule['source'] == 'team':
					prefix = "@"
				else:
					continue
					
				if int(rule['src']) == 1:
					zconfig.set(section_name,prefix + rule['name'],'r')
				elif int(rule['src']) == 2:
					zconfig.set(section_name,prefix + rule['name'],'rw')
		
		with open(self.config['SVN_AUTHZ_FILE'],'wb') as cfp:
			zconfig.write(cfp)
			cfp.flush()
			os.fsync(cfp.fileno())
			
		syslog.syslog('SVN authz file regenerated')
		curd.close()

################################################################################
			
	def regenerate_samba_hooks_file(self):	
		smbconf = ""
	
		curd = self.get_cursor()
		curd.execute('SELECT * FROM `repos` WHERE `state` = 1')
		repos = curd.fetchall()
		
		for repo in repos:
		
			curd.execute('SELECT * FROM `rules` WHERE `rid` = %s', (repo['id']))
			rules = curd.fetchall()
			
			users = ""
			
			for rule in rules:
				if str(rule['source']) == 'internal' and str(rule['admin']) == '1':
					users = users + rule['name'] + " "
					
			svn_path = os.path.join(self.config['SVN_ROOT'],repo['name'])
					
			smbconf = smbconf + """[%s]
comment     = Subversion Hooks directory for %s
path        = %s/hooks/
browseable  = yes
writable    = yes
read only   = no
force user  = apache
force group = apache
valid users = %s

""" % (
				repo['name'],
				repo['name'],
				svn_path,
				users
			)
			
		
		## Now write
		with open(self.config['SAMBA_CONFIG_FILE'],'w') as sfp:
			sfp.write(smbconf)
			sfp.flush()
			os.fsync(sfp.fileno())
			
		syslog.syslog('Samba SVN hooks configuration regenerated')
		curd.close()
		
################################################################################
			
	def regenerate_autoversion_config(self):	
		autoconf = ""
	
		curd = self.get_cursor()
		curd.execute('SELECT * FROM `repos` WHERE `state` = 1 AND `autoversion` = 1')
		repos = curd.fetchall()
		
		for repo in repos:
					
			autoconf = autoconf + """
<Location /svn/%s>
SVNAutoversioning on
</Location>
""" % (repo['name'])
			
		
		## Now write
		with open(self.config['SVN_AUTOVERSION_CONFIG_FILE'],'w') as sfp:
			sfp.write(autoconf)
			sfp.flush()
			os.fsync(sfp.fileno())
			
		syslog.syslog('SVN autoversion configuration regenerated')
		curd.close()
		
################################################################################

	def repo_create(self,name,src_type,web_type,initial_admin):
		if not re.search(r'^[a-zA-Z0-9_\-]{3,50}$', name):
			## This should never happen of course, but we do this test just to make sure.
			return (False,"Invalid repository name")
			
		if src_type == 'svn': 
			try:
				src_path = self.svn_create(name)
			except Exception as ex:
				syslog.syslog('SVN creation call failed: ' + str(ex))
				return (False,"Failed to create repository. The error was: " + str(ex))
		elif src_type == 'git': 
			try:
				src_path = self.git_create(name)
			except Exception as ex:
				syslog.syslog('git init call failed: ' + str(ex))
				syslog.syslog(traceback.format_exc())
				return (False,"Failed to create repository. The error was: " + str(ex))
		elif src_type == 'hg': 
			try:
				src_path = self.hg_create(name)
			except Exception as ex:
				syslog.syslog('hg init call failed: ' + str(ex))
				syslog.syslog(traceback.format_exc())
				return (False,"Failed to create repository. The error was: " + str(ex))
		elif src_type == 'none':
			src_path = ""
			
		if web_type == 'trac':
			try:
				trac_path = self.trac_create(name,src_type,src_path)
				self.trac_add_admin(trac_path,initial_admin)
			except Exception as ex:
				syslog.syslog('Trac creation call failed:' + str(ex))
				return False,"Failed to create repository. The error was: " + str(ex)
				
		return True,"Success"

################################################################################

	def repo_add_web(self,name,web_type):
		if DEBUG: syslog.syslog('method repo_add_web called')

		if not re.search(r'^[a-zA-Z0-9_\-]{3,50}$', name):
			## This should never happen of course, but we do this test just to make sure.
			return (False,"Invalid repository name")
			
		try:
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()
			
			if repo == None:
				raise InternalError("Could not find repo '" + name + "' in the database")
								
			if web_type == 'trac':
				if repo['src_type'] == 'svn':
					src_path = os.path.join(self.config['SVN_ROOT'],name)
				elif repo['src_type'] == 'git':
					src_path = os.path.join(self.config['GIT_ROOT'],name)
				elif repo['src_type'] == 'hg':
					src_path = os.path.join(self.config['HG_ROOT'],name)
				elif repo['src_type'] == 'none':
					src_path = ''

				trac_path = self.trac_create(name,repo['src_type'],src_path)
					
				curd.execute('SELECT * FROM `rules` WHERE `rid` = %s',(repo['id']))
				rules = curd.fetchall()
			
				for rule in rules:
					if rule['source'] == 'internal' and str(rule['admin']) == "1":
						self.trac_add_admin(trac_path,rule['name'])
						
		except Exception as ex:
			syslog.syslog('Trac creation call failed:' + str(ex))
			return False,"Failed to add Trac. The error was: " + str(ex)
					
		return True,"Success"

################################################################################
		
	def repo_add_admin(self,name,username):
		if DEBUG: syslog.syslog('method repo_add_admin called')
		
		try:
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()
			
			if repo == None:
				raise InternalError("Could not find repo '" + name + "' in the database")
			
			if repo['web_type'] == 'trac':	
				## Check trac folder exists
				trac_path = os.path.join(self.config['TRAC_ROOT'],name)
				if not os.path.lexists(trac_path):
					return False,"That repository does not exist!"
					
				self.trac_add_admin(trac_path,username)
				
		except Exception as ex:
			syslog.syslog('Could not add admin to repo:' + str(ex))
			return False,"Could not grant admin rights. The error was: " + str(ex)
			
		return True,"Success"

################################################################################

	def repo_remove_admin(self,name,username):
		if DEBUG: syslog.syslog('method repo_remove_admin called')
		
		try:
		
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()
			
			if repo == None:
				raise InternalError("Could not find repo '" + name + "' in the database")
			
			if repo['web_type'] == 'trac':	
		
				## Check trac folder exists
				trac_path = os.path.join(self.config['TRAC_ROOT'],name)
				if not os.path.lexists(trac_path):
					return False,"That repository does not exist!"
					

				self.trac_remove_admin(trac_path,username)
		except Exception as ex:
			syslog.syslog('Could not remove admin from repo:' + str(ex))
			traceback.print_exc(file=sys.stdout)
			return False,"Could not revoke admin rights. The error was: " + str(ex)
			
		return True,"Success"

################################################################################
		
	def repo_suspend(self,name):		
		if DEBUG: syslog.syslog('method repo_suspend called')
		
		try:
		
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()

			
			if repo == None:
				raise InternalError("Could not suspend repo name '" + name + "' because it does not exist!")
				
			if repo['src_type'] == 'svn':
			
				svn_path = os.path.join(self.config['SVN_ROOT'],name)
				svn_suspend_path = os.path.join(self.config['SVN_SUSPENDED_ROOT'],name)
				shutil.move(svn_path,svn_suspend_path)
				syslog.syslog('Moved svn directory to suspended for repo: ' + name)
			
				self.regenerate_authz_file()
				self.regenerate_samba_hooks_file()
				self.regenerate_autoversion_config()

			elif repo['src_type'] == 'git':
			
				git_path = os.path.join(self.config['GIT_ROOT'],name)
				git_suspend_path = os.path.join(self.config['GIT_SUSPENDED_ROOT'],name)
				shutil.move(git_path,git_suspend_path)
				syslog.syslog('Moved git directory to suspended for repo: ' + name)
			
				self.git_auth_config(name)

			elif repo['src_type'] == 'hg':
			
				hg_path = os.path.join(self.config['HG_ROOT'],name)
				hg_suspend_path = os.path.join(self.config['HG_SUSPENDED_ROOT'],name)
				shutil.move(hg_path,hg_suspend_path)
				syslog.syslog('Moved hg directory to suspended for repo: ' + name)
			
				self.hg_auth_config(name)
				
			if repo['web_type'] == 'trac':
				trac_path = os.path.join(self.config['TRAC_ROOT'],name)
				trac_suspend_path = os.path.join(self.config['TRAC_SUSPENDED_ROOT'],name)
				shutil.move(trac_path,trac_suspend_path)
				syslog.syslog('Moved trac directory to suspended for repo: ' + name)

				self.trac_auth_config(name)

			self.server_graceful()
		
		except Exception as ex:
		
			syslog.syslog('Could not suspend repo ' + name + ':' + str(ex))
			traceback.print_exc(file=sys.stdout)
			return False,"Could not suspend the repo. The error was: " + str(ex)

		return True,""

################################################################################
		
	def repo_enable(self,name):
		if DEBUG: syslog.syslog('method repo_enable called')

		try:
		
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()
			
			if repo == None:
				raise InternalError("Could not enable repo name '" + name + "' because it does not exist!")
				
			if repo['src_type'] == 'svn':
			
				svn_path = os.path.join(self.config['SVN_ROOT'],name)
				svn_suspend_path = os.path.join(self.config['SVN_SUSPENDED_ROOT'],name)
				shutil.move(svn_suspend_path,svn_path)
				syslog.syslog('Moved svn directory to active for repo: ' + name)
			
				self.regenerate_authz_file()
				self.regenerate_samba_hooks_file()
				self.regenerate_autoversion_config()

			elif repo['src_type'] == 'git':
			
				git_path = os.path.join(self.config['GIT_ROOT'],name)
				git_suspend_path = os.path.join(self.config['GIT_SUSPENDED_ROOT'],name)
				shutil.move(git_suspend_path,git_path)
				syslog.syslog('Moved git directory to active for repo: ' + name)
			
				self.git_auth_config(name)

			elif repo['src_type'] == 'hg':
			
				hg_path = os.path.join(self.config['HG_ROOT'],name)
				hg_suspend_path = os.path.join(self.config['HG_SUSPENDED_ROOT'],name)
				shutil.move(hg_suspend_path,hg_path)
				syslog.syslog('Moved hg directory to active for repo: ' + name)
			
				self.hg_auth_config(name)
				
			if repo['web_type'] == 'trac':
				trac_path = os.path.join(self.config['TRAC_ROOT'],name)
				trac_suspend_path = os.path.join(self.config['TRAC_SUSPENDED_ROOT'],name)
				shutil.move(trac_suspend_path,trac_path)
				syslog.syslog('Moved trac directory to active for repo: ' + name)

				self.trac_auth_config(name)
			
			self.server_graceful()
		
		except Exception as ex:
		
			syslog.syslog('Could not enable repo ' + name + ':' + str(ex))
			traceback.print_exc(file=sys.stdout)
			return False,"Could not enable the repo. The error was: " + str(ex)

		return True,""
		
################################################################################

	def repo_delete(self,name):
		if DEBUG: syslog.syslog('method repo_delete called')

		try:
		
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()
			
			if repo == None:
				raise InternalError("Could not delete repo name '" + name + "' because it does not exist!")
				
			if repo['src_type'] == 'svn':
			
				svn_path = os.path.join(self.config['SVN_ROOT'],name)
				svn_delete_path = os.path.join(self.config['SVN_DELETED_ROOT'],name)
				shutil.move(svn_path,svn_delete_path)
				syslog.syslog('Moved svn directory to deleted for repo: ' + name)
			
				self.regenerate_authz_file()
				self.regenerate_samba_hooks_file()
				self.regenerate_autoversion_config()

			elif repo['src_type'] == 'git':
			
				git_path = os.path.join(self.config['GIT_ROOT'],name)
				git_delete_path = os.path.join(self.config['GIT_DELETED_ROOT'],name)
				shutil.move(git_path,git_delete_path)
				syslog.syslog('Moved git directory to deleted for repo: ' + name)
			
				self.git_auth_config(name)

			elif repo['src_type'] == 'hg':
			
				hg_path = os.path.join(self.config['HG_ROOT'],name)
				hg_delete_path = os.path.join(self.config['HG_DELETED_ROOT'],name)
				shutil.move(hg_path,hg_delete_path)
				syslog.syslog('Moved hg directory to deleted for repo: ' + name)
			
				self.hg_auth_config(name)
				
			if repo['web_type'] == 'trac':
				trac_path = os.path.join(self.config['TRAC_ROOT'],name)
				trac_delete_path = os.path.join(self.config['TRAC_DELETED_ROOT'],name)
				shutil.move(trac_path,trac_delete_path)
				syslog.syslog('Moved trac directory to deleted for repo: ' + name)

				self.trac_auth_config(name)
			
			self.server_graceful()
		
		except Exception as ex:
		
			syslog.syslog('Could not delete repo ' + name + ':' + str(ex))
			traceback.print_exc(file=sys.stdout)
			return False,"Could not delete the repo. The error was: " + str(ex)

		return True,""

################################################################################
		
	def repo_update_rules(self,name):
		if DEBUG: syslog.syslog('method repo_update_rules called')

		try:	

			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()
			
			if repo == None:
				raise InternalError("Could not delete repo name '" + name + "' because it does not exist!")
				
			if repo['src_type'] == 'svn':
				self.regenerate_authz_file()
			elif repo['src_type'] == 'git':
				self.git_auth_config(name)
			elif repo['src_type'] == 'hg':
				self.hg_auth_config(name)
				
			if repo['web_type'] == 'trac':
				self.trac_auth_config(name)
				self.server_graceful()
				
		except Exception as ex:
			syslog.syslog('Permission rebuild failed:' + str(ex))
			return False,"Failed to rebuild permissions. The error was: " + str(ex)
					
		return True,""

################################################################################
		
	def repo_update_web_security(self,name):
		if DEBUG: syslog.syslog('method repo_update_web_security called')

		try:
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()
			
			if repo == None:
				raise InternalError("Could not update web security for repo '" + name + "' because it does not exist!")
				
			if repo['web_type'] == 'trac':
				self.trac_auth_config(name)
				self.server_graceful()

		except Exception as ex:
			syslog.syslog('Unable to set web security flag:' + str(ex))
			return False,"Failed to set web security flag. The error was: " + str(ex)		
		
		return True,""

################################################################################
	
	def repo_update_src_notify_email(self,name,address):
		if DEBUG: syslog.syslog('method repo_update_src_notify_email called')

		try:
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
			repo = curd.fetchone()
			
			if repo == None:
				raise InternalError("Could not update web security for repo '" + name + "' because it does not exist!")
				
			if repo['src_type'] == 'svn':
				self.svn_notify_config(name,address)

		except Exception as ex:
			syslog.syslog('Unable to set svn notify email:' + str(ex))
			return False,"Failed to set set notification e-mail. The error was: " + str(ex)		
		
		return True,""

################################################################################
		
	def update_autoversion(self):
		if DEBUG: syslog.syslog('method update_autoversion called')

		try:
			self.regenerate_autoversion_config()
			self.server_graceful()
		except Exception as ex:
			syslog.syslog('Unable to rebuild svn autoversion config:' + str(ex))
			return False,"Failed to set set autoversion. The error was: " + str(ex)		
		
		return True,""

################################################################################
		
	def team_delete_update(self):
		if DEBUG: syslog.syslog('method team_delete_update called')
		
		try:
			self.regenerate_authz_file()
			
			curd = self.get_cursor()
			curd.execute('SELECT * FROM `repos` WHERE `state` = 1')
			repos = curd.fetchall()
			
			for repo in repos:

				if repo['web_type'] == 'trac':
					self.trac_auth_config(repo['name'])

				if repo['src_type'] == 'git':
					self.git_auth_config(repo['name'])
				elif repo['src_type'] == 'hg':
					self.hg_auth_config(repo['name'])
			
			self.server_graceful()

		except Exception as ex:
			syslog.syslog('Unable to process team deletion update:' + str(ex))
			return False,"Failed to update rules after team delete. The error was: " + str(ex)				
		
		return True,""

################################################################################
		
	def team_members_updated(self):
		if DEBUG: syslog.syslog('method team_members_updated called')
		
		try:
			self.regenerate_authz_file()
		except Exception as ex:
			syslog.syslog('Unable to process team members update:' + str(ex))
			return False,"Failed to update rules after team members update. The error was: " + str(ex)				
		
		return True,""
		
################################################################################

def signal_handler_term(signal, frame):
	signal_handler('SIGTERM')
	
################################################################################
	
def signal_handler_int(signal, frame):
	signal_handler('SIGINT')
	
################################################################################
		
def signal_handler(signal):
	syslog.syslog('Caught signal ' + str(signal) + ' - exiting trackitd/' + str(VERSION))
	Pyro4.core.Daemon.shutdown(pyro_daemon)
	sys.exit(0)

################################################################################
	
if __name__ == "__main__":
	## Set up the daemon
	trackit     = TracKitDaemon()
	trackit.load_config(TRACKIT_CONFIG_FILE)

	## Drop privileges
	os.setgid(trackit.config['TRACKITD_SET_GID'])
	os.setuid(trackit.config['TRACKITD_SET_UID'])
	
	signal.signal(signal.SIGTERM, signal_handler_term)
	signal.signal(signal.SIGINT, signal_handler_int)
	pyro_daemon = Pyro4.Daemon(host='localhost',port=1888)
	pyro_daemon._pyroHmacKey = trackit.config['TRACKITD_KEY']
	uri         = pyro_daemon.register(trackit,'trackit-daemon')
	syslog.syslog('Ready to serve clients on URI: ' + str(uri))
	pyro_daemon.requestLoop()
