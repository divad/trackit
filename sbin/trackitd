#!/usr/bin/python
#
# This file is part of trackit.
#
# trackit is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# trackit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with trackit.  If not, see <http://www.gnu.org/licenses/>.

import Pyro4
import syslog
import signal
import sys
import os.path
import os
import subprocess
import re
import ConfigParser
import MySQLdb as mysql
import traceback # remove
import ldap
import imp

TRACKIT_CONFIG_FILE = '/data/trackit/trackit.conf'
VERSION        = 0.7
DEBUG = True

Pyro4.config.SERVERTYPE = "multiplex"
Pyro4.config.SOCK_REUSE = True

class InternalError(Exception):
	def __init__(self, message, error_data={}):
		super(InternalError, self).__init__(message)
		self.data = error_data

class TracKitDaemon(object):

	def __init__(self):
		## Open syslog 
		syslog.openlog("trackitd",syslog.LOG_PID)
		syslog.syslog('Starting trackitd/' + str(VERSION))

################################################################################
		
	def db_connect(self):
		## Connect to MySQL
		self.db = mysql.connect(self.config['DB_SERV'],self.config['DB_USER'],self.config['DB_PASS'],self.config['DB_NAME'])
		return self.db.cursor(mysql.cursors.DictCursor)
		
	def load_config(self, filename):
		d = imp.new_module('config')
		d.__file__ = filename
		try:
			with open(filename) as config_file:
				exec(compile(config_file.read(), filename, 'exec'), d.__dict__)
		except IOError as e:
			syslog.syslog('Unable to load configuration file (%s)' % e.strerror)
			sys.exit(1)
		self.config = {}
		for key in dir(d):
			if key.isupper():
				self.config[key] = getattr(d, key)
				
		return True

################################################################################
		
	def db_close(self):
		self.db.close()
		
################################################################################
		
	def sysexec(self,command):
		commands = command.split(' ')
		proc = subprocess.Popen(commands,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
		(stdoutdata, stderrdata) = proc.communicate()
		
		return (proc.returncode,str(stdoutdata),str(stderrdata))
		
################################################################################
		
	def svn_create(self,name):
		## Check the svn folder does not exist
		svn_path = os.path.join(self.config['SVN_ROOT'],name)
		if os.path.lexists(svn_path):
			syslog.syslog('Could not create svn repo ' + svn_path + ': the directory already exists')
			raise InternalError("The subversion repository path " + svn_path + " already exists")

		## Run svnadmin create
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/svnadmin create ' + svn_path)
		if rcode > 0:
			syslog.syslog('Could not create svn repo ' + svn_path + ': svnadmin returned an error code')
			syslog.syslog('svnadmin stdout:' + stdoutdata)
			syslog.syslog('svnadmin stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("The subversion repository could not be created due to an internal error. Please contact your system administrator.",error_data)
		
		syslog.syslog('Created svn repository ' + name)
		self.regenerate_authz_file()
		self.regenerate_samba_hooks_file()
		return svn_path
		
################################################################################
			
	def trac_create(self,name,svn_path,repo_description="N/A"):
		## Check trac folder does not exist
		trac_path = os.path.join(self.config['TRAC_ROOT'],name)
		if os.path.lexists(trac_path):
			raise InternalError("The trac path " + trac_path + " already exists")
	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/trac-admin ' + trac_path + ' initenv ' + name + ' sqlite:db/trac.db svn ' + svn_path)

		if rcode > 0:
			syslog.syslog('Could not trac instance ' + trac_path + ': trac-admin returned an error code')
			syslog.syslog('trac-admin stdout:' + stdoutdata)
			syslog.syslog('trac-admin stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("The Trac instance could not be created due to an internal error. Please contact your system administrator.",error_data)
		else:
			syslog.syslog('Created trac instance ' + name)

		## Open the config file		
		config_path = os.path.join(trac_path,'conf','trac.ini')
		
		tconfig = ConfigParser.RawConfigParser()
		tconfig.read(config_path)

		## LOGO
		tconfig.set('header_logo','src','https://www.southampton.ac.uk/images/bg_logo_small.png')
		tconfig.set('header_logo','alt','Trac')
		tconfig.set('header_logo','link','https://trac.soton.ac.uk/' + name + '/')
		
		## Enable SVN component
		tconfig.add_section('components')
		tconfig.set('components','tracopt.versioncontrol.svn.*','enabled')

		## email notifications
		tconfig.set('notification','always_notify_owner','true')
		tconfig.set('notification','always_notify_reporter','true')
		tconfig.set('notification','always_notify_updater','true')
		tconfig.set('notification','smtp_default_domain','soton.ac.uk')
		tconfig.set('notification','smtp_enabled','true')
		tconfig.set('notification','smtp_from','noreply@soton.ac.uk')
		tconfig.set('notification','smtp_replyto','noreply@soton.ac.uk')
		
		## other settings
		tconfig.set('project','admin','noreply@soton.ac.uk')
		tconfig.set('project','descr',repo_description)
		
		with open(config_path,'wb') as cfp:
			tconfig.write(cfp)
			cfp.flush()
			os.fsync(cfp.fileno())
			
		## Create the auth file
		self.trac_auth_config(name)
		
		## Restart httpd :(
		self.server_graceful()
		
		return trac_path

################################################################################	
		
	def server_graceful(self):
		## TODO configtest
		## TODO email about errors
		
		syslog.syslog('httpd graceful restart requested')
	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/sudo -n /usr/sbin/apachectl graceful')

		if rcode > 0:
			syslog.syslog('CRITICAL: httpd graceful restart failed - apachectl returned an error code:' + rcode)
			syslog.syslog('trac-admin stdout:' + stdoutdata)
			syslog.syslog('trac-admin stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("The web server restart failed. Please contact ServiceLine",error_data)
		else:
			syslog.syslog('httpd graceful restart OK')

		
################################################################################	
		
	def trac_auth_config(self,name):			
		curd = self.db_connect()
		curd.execute('SELECT * FROM `repos` WHERE `name` = %s',(name))
		repo = curd.fetchone()
		
		if not repo == None:
			## create set
			required_users = set()
			ldap_groups    = ""
			teamauthz_required = False
			teamauthz_string = ""
			
			## get rules now
			curd.execute('SELECT * FROM `rules` WHERE `rid` = %s', (repo['id']))
			rules = curd.fetchall()	

			for rule in rules:
				if rule['web'] == 1:
					if rule['source'] == 'internal':
						required_users.add(rule['name'])
						
					elif rule['source'] == 'team':
						curd.execute('SELECT * FROM `teams` WHERE `name` = %s',(rule['name']))
						team = curd.fetchone()
						
						if not team == None:
							teamauthz_required = True
							teamauthz_string += "\n\tRequire group " + team['name']
								
					elif rule['source'] == 'adgroup':
						groupdn = self.ldap_get_group_dn(rule['name'])
						
						if not groupdn == None:
							ldap_groups += "\n\tRequire ldap-group " + groupdn
					
		location = "/trac/" + name 
		
		if repo['web_security'] == 1:
			location = location + "/login"
					
		users_string = ""
		for user in required_users:
			users_string = users_string + user + " "
			
		if len(users_string) > 0:
			users_string = "\n\tRequire ldap-user " + users_string
			
		if teamauthz_required:
			teamauthz_string = "\n\tWSGIAuthGroupScript /data/trackit/trackit/teamauthz.wsgi" + teamauthz_string
	
		f = open(os.path.join(self.config['TRAC_CONF_DIR'], name + ".conf"), 'w')
		f.write("""<Location %s>
AuthType Basic
AuthName "%s Trac Project"
AuthBasicProvider ldap
AuthLDAPUrl ldaps://nlbldap.soton.ac.uk/dc=soton,dc=ac,dc=uk?cn?? %s %s %s
</Location>
""" % (
			location,
			name,
			teamauthz_string,
			users_string,
			ldap_groups,
		))
		
		f.flush()
		os.fsync(f.fileno())
		f.close()
		
		syslog.syslog('trac auth config rebuilt for instance ' + name)


################################################################################

	def ldap_get_group_dn(self,group_name):

		ldapserver = ldap.initialize(self.config['LDAP_SERVER'])
		results = ldapserver.search_s(self.config['LDAP_BASE'], ldap.SCOPE_SUBTREE,"(cn=" + group_name +")")

		for result in results:
			dn    = result[0]
			attrs = result[1]

			if not dn == None:
				if "member" in attrs:
					return dn
							
		return None

################################################################################	
		
	def trac_add_admin(self,trac_path,username):	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/trac-admin ' + trac_path + ' permission add ' + username + ' TRAC_ADMIN')		

		if rcode > 0:
			syslog.syslog('Error returned from trac-admin permission add on instance ' + trac_path + '. Error code:' + str(rcode))
			syslog.syslog('trac-admin stdout:' + stdoutdata)
			syslog.syslog('trac-admin stderr:' + stderrdata)			
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("Could not set trac permissions",error_data)
		else:
			syslog.syslog("Granted TRAC_ADMIN to " + username + " on instance " + trac_path)

################################################################################
			
	def trac_remove_admin(self,trac_path,username):	
		rcode, stdoutdata, stderrdata = self.sysexec('/usr/bin/trac-admin ' + trac_path + ' permission remove ' + username + ' TRAC_ADMIN')		
			
		if rcode > 0:
			syslog.syslog('Error returned from trac-admin permission remove on instance ' + trac_path + '. Error code:' + str(rcode))
			syslog.syslog('trac-admin stdout:' + stdoutdata)
			syslog.syslog('trac-admin stderr:' + stderrdata)
			
			error_data = {'stdout': stdoutdata, 'stderr': stderrdata, 'rcode': rcode}
			raise InternalError("Could not set trac permissions",error_data) 
		else:
			syslog.syslog("Revoked TRAC_ADMIN from " + username + " on instance " + trac_path)

################################################################################
			
	def regenerate_authz_file(self):
		## regenerate the entire authz file
		zconfig = ConfigParser.RawConfigParser()
		
		## Generate teams
		zconfig.add_section('groups')
		curd = self.db_connect()
		curd.execute('SELECT * FROM `teams` ORDER BY `name`')
		teams = curd.fetchall()
		
		for team in teams:
			curd.execute('SELECT * FROM `team_members` WHERE `tid` = %s', (team['id']))
			members = curd.fetchall()
			
			memberstr = ""
			for member in members:
				memberstr += " " + member['username'] + ","
				
			if memberstr.endswith(','):
				## remove the trailing comma and starting space
				memberstr = memberstr[1:-1]
				zconfig.set('groups',team['name'],memberstr)
				
		## Generate each repo rules
		curd.execute('SELECT * FROM `repos`')
		repos = curd.fetchall()
		
		for repo in repos:
			section_name = repo['name'] + ":/"
			zconfig.add_section(section_name)
			curd.execute('SELECT * FROM `rules` WHERE `rid` = %s', (repo['id']))
			rules = curd.fetchall()	

			for rule in rules:
				if rule['source'] == 'internal':
					prefix = ""
				elif rule['source'] == 'team':
					prefix = "@"
				else:
					continue
					
				if int(rule['src']) == 1:
					zconfig.set(section_name,prefix + rule['name'],'r')
				elif int(rule['src']) == 2:
					zconfig.set(section_name,prefix + rule['name'],'rw')
		
		with open(self.config['SVN_AUTHZ_FILE'],'wb') as cfp:
			zconfig.write(cfp)
			cfp.flush()
			os.fsync(cfp.fileno())
			
		syslog.syslog('SVN authz file regenerated')
		curd.close()
		self.db_close()

################################################################################
			
	def regenerate_samba_hooks_file(self):	
		smbconf = ""
	
		curd = self.db_connect()
		curd.execute('SELECT * FROM `repos` WHERE `state` = 1')
		repos = curd.fetchall()
		
		for repo in repos:
		
			curd.execute('SELECT * FROM `rules` WHERE `rid` = %s', (repo['id']))
			rules = curd.fetchall()
			
			users = ""
			
			for rule in rules:
				if str(rule['source']) == 'internal' and str(rule['admin']) == '1':
					users = users + rule['name'] + " "
					
			svn_path = os.path.join(self.config['SVN_ROOT'],repo['name'])
					
			smbconf = smbconf + """[%s]
comment     = Subversion Hooks directory for %s
path        = %s/hooks/
browseable  = yes
writable    = yes
read only   = no
force user  = apache
force group = apache
valid users = %s

""" % (
				repo['name'],
				repo['name'],
				svn_path,
				users
			)
			
		
		## Now write
		with open(self.config['SAMBA_CONFIG_FILE'],'w') as sfp:
			sfp.write(smbconf)
			sfp.flush()
			os.fsync(sfp.fileno())
			
		syslog.syslog('Samba SVN hooks configuration regenerated')
		curd.close()
		self.db_close()
		
################################################################################

	def repo_create(self,name,src_type,web_type,initial_admin):
		if not re.search(r'^[a-zA-Z0-9_\-]{3,50}$', name):
			## This should never happen of course, but we do this test just to make sure.
			return (False,"Invalid repository name")
			
		## we only support svn atm
		if not src_type == 'svn': 
			return (False,"Invalid repository src type")
			
		if src_type == 'svn': 
			try:
				svn_path = self.svn_create(name)
			except Exception as ex:
				syslog.syslog('SVN creation call failed')
				return (False,"Failed to create repository. The error was: " + str(ex))
			
		if web_type == 'trac':
			try:
				trac_path = self.trac_create(name,svn_path)
				self.trac_add_admin(trac_path,initial_admin)
			except Exception as ex:
				syslog.syslog('Trac creation call failed:' + str(ex))
				return False,"Failed to create repository. The error was: " + str(ex)
				
		return True,"Success"
		
	def repo_add_admin(self,name,username):
		if DEBUG: syslog.syslog('method repo_add_admin called')
	
		## Check trac folder exists
		trac_path = os.path.join(self.config['TRAC_ROOT'],name)
		if not os.path.lexists(trac_path):
			return False,"That repository does not exist!"
			
		try:
			self.trac_add_admin(trac_path,username)
		except Exception as ex:
			syslog.syslog('Could not add admin to Trac:' + str(ex))
			return False,"Could not grant admin rights. The error was: " + str(ex)
			
		return True,"Success"

	def repo_remove_admin(self,name,username):
		if DEBUG: syslog.syslog('method repo_remove_admin called')
	
		## Check trac folder exists
		trac_path = os.path.join(self.config['TRAC_ROOT'],name)
		if not os.path.lexists(trac_path):
			return False,"That repository does not exist!"
			
		try:
			self.trac_remove_admin(trac_path,username)
		except Exception as ex:
			syslog.syslog('Could not remove admin from Trac:' + str(ex))
			traceback.print_exc(file=sys.stdout)
			return False,"Could not revoke admin rights. The error was: " + str(ex)
			
		return True,"Success"
			
	def repo_suspend(self,name):		
		if DEBUG: syslog.syslog('method repo_suspend called')
#		self.regenerate_samba_hooks_file()

		return True,""
		
	def repo_enable(self,name):
		if DEBUG: syslog.syslog('method repo_enable called')
#		self.regenerate_samba_hooks_file()

		return True,""
		
	def repo_delete(self,name):
		if DEBUG: syslog.syslog('method repo_delete called')
		#		self.regenerate_samba_hooks_file()

		return True,""
		
	def repo_update_rules(self,name):
		if DEBUG: syslog.syslog('method repo_update_rules called')

		try:		
			self.regenerate_authz_file()
			self.trac_auth_config(name)
			self.server_graceful()
		except Exception as ex:
			syslog.syslog('Permission rebuild failed:' + str(ex))
			return False,"Failed to rebuild permissions. The error was: " + str(ex)
			
		## todo...trac update only if it has trac...
		
		return True,""
		
	def repo_update_web_security(self,name):
		if DEBUG: syslog.syslog('method repo_update_web_security called')

		try:
			self.trac_auth_config(name)
			self.server_graceful()
		except Exception as ex:
			syslog.syslog('Unable to rebuild trac auth config:' + str(ex))
			return False,"Failed to set web security flag. The error was: " + str(ex)		
		
		return True,""
	
	def repo_update_src_notify_email(self,name):
		if DEBUG: syslog.syslog('method repo_update_src_notify_email called')
		## no need to restart
		return True,""
		
	def repo_update_autoversion(self,name):
		if DEBUG: syslog.syslog('method repo_update_autoversion called')
			
		## probably need to restart apache graceful
		return True,""
		
	def team_delete_update(self):
		if DEBUG: syslog.syslog('method team_delete_update called')
		
		try:
			self.regenerate_authz_file()
			
			## TODO consider being smarter about this. Only regenerate repos which ever referenced this team?
			## would mean doing the SQL delete after htis call instead of doing it first as now.
			
			curd = self.db_connect()
			curd.execute('SELECT * FROM `repos` WHERE `state` = 1')
			repos = curd.fetchall()
			
			for repo in repos:
				self.trac_auth_config(repo['name'])
			
			self.server_graceful()
			self.db_close()

		except Exception as ex:
			syslog.syslog('Unable to process team deletion update:' + str(ex))
			return False,"Failed to update rules after team delete. The error was: " + str(ex)				
		
		return True,""
		
	def team_members_updated(self):
		if DEBUG: syslog.syslog('method team_members_updated called')
		
		try:
			self.regenerate_authz_file()
		except Exception as ex:
			syslog.syslog('Unable to process team members update:' + str(ex))
			return False,"Failed to update rules after team members update. The error was: " + str(ex)				
		
		return True,""
		
################################################################################

def signal_handler_term(signal, frame):
	signal_handler('SIGTERM')
	
################################################################################
	
def signal_handler_int(signal, frame):
	signal_handler('SIGINT')
	
################################################################################
		
def signal_handler(signal):
	syslog.syslog('Caught signal ' + str(signal) + ' - exiting trackitd/' + str(VERSION))
	Pyro4.core.Daemon.shutdown(pyro_daemon)
	sys.exit(0)

################################################################################
	
if __name__ == "__main__":	
	## Set up the daemon
	trackit     = TracKitDaemon()
	trackit.load_config(TRACKIT_CONFIG_FILE)

	## Drop privileges
	os.setgid(trackit.config['TRACKITD_SET_GID'])
	os.setuid(trackit.config['TRACKITD_SET_UID'])
	
	signal.signal(signal.SIGTERM, signal_handler_term)
	signal.signal(signal.SIGINT, signal_handler_int)
	pyro_daemon = Pyro4.Daemon(host='localhost',port=1888)
	pyro_daemon._pyroHmacKey = trackit.config['TRACKITD_KEY']
	uri         = pyro_daemon.register(trackit,'trackit-daemon')
	syslog.syslog('Ready to serve clients on URI: ' + str(uri))
	pyro_daemon.requestLoop()
